/**************************************************************************
 * C S 429 system emulator
 * 
 * instr_Decode.c - Decode stage of instruction processing pipeline.
 **************************************************************************/ 

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <assert.h>
#include "err_handler.h"
#include "instr.h"
#include "instr_pipeline.h"
#include "forward.h"
#include "machine.h"
#include "hw_elts.h"

#define SP_NUM 31
#define XZR_NUM 32

extern machine_t guest;
extern mem_status_t dmem_status;

extern int64_t W_wval;

/*
 * Control signals for D, X, M, and W stages.
 * Generated by D stage logic.
 * D control signals are consumed locally. 
 * Others must be buffered in pipeline registers.
 * STUDENT TO-DO:
 * Generate the correct control signals for this instruction's
 * future stages and write them to the corresponding struct.
 */

static comb_logic_t 
generate_DXMW_control(opcode_t op, d_ctl_sigs_t *D_sigs, x_ctl_sigs_t *X_sigs, m_ctl_sigs_t *M_sigs, w_ctl_sigs_t *W_sigs) {
    //d sigs
    D_sigs->src2_sel = (op == OP_STUR);
    //x sigs
    X_sigs->valb_sel = (op == OP_SUBS_RR || op == OP_CMP_RR || op == OP_MVN || op == OP_ORR_RR ||op == OP_ADDS_RR || op == OP_EOR_RR || op == OP_ANDS_RR || op == OP_TST_RR);
    X_sigs->set_CC = (op == OP_SUBS_RR || op == OP_CMP_RR || op == OP_ANDS_RR || op == OP_ADDS_RR || op == OP_TST_RR);
    //m sigs
    M_sigs->dmem_read = (op == OP_LDUR);
    M_sigs->dmem_write = (op == OP_STUR);
    //w sigs
    W_sigs->dst_sel = (op == OP_BL);
    W_sigs->wval_sel = (op == OP_LDUR);
    W_sigs->w_enable = (op != OP_B_COND && op != OP_BL && op != OP_RET && op != OP_STUR && op != OP_B && op != OP_NOP && op != OP_HLT);

    return;
}

/*
 * Logic for extracting the immediate value for M-, I-, and RI-format instructions.
 * STUDENT TO-DO:
 * Extract the immediate value and write it to *imm.
 */

static comb_logic_t 
extract_immval(uint32_t insnbits, opcode_t op, int64_t *imm) {
    int constFive = 5;
    int constSix = 6;
    int constTwel = 12;
    int constNin = 9;
    int constNinteen = 19;
    int constTen = 10;
    if (op == OP_STUR || op == OP_LDUR) {
        *imm = bitfield_u32(insnbits, constTwel, constNin);
    }
    else if (op == OP_LDUR){
        *imm = bitfield_u32(insnbits, constTwel, constNin);
    }
    else if (op == OP_ADRP) {
        *imm = (bitfield_u32(insnbits, constFive, constNinteen) << 14) | (bitfield_u32(insnbits, 29, 2) << constTwel);
    }
    else if (op == OP_MOVK) {
        *imm = bitfield_u32(insnbits, constFive, 16);
    }
    else if (op == OP_MOVZ){
        *imm = bitfield_u32(insnbits, constFive, 16);
    }
    else if (op == OP_ADD_RI || op == OP_SUB_RI || op == OP_ASR) {
        *imm = bitfield_u32(insnbits, constTen, constTwel);
    }
    else if (op == OP_SUB_RI) {
        *imm = bitfield_u32(insnbits, constTen, constTwel);
    }
    else if (op == OP_ASR) {
        *imm = bitfield_u32(insnbits, constTen, constTwel);
    }
    else if (op == OP_LSR) {
        *imm = bitfield_u32(insnbits, constTen, constSix);
    }
    else if (op == OP_LSL || op == OP_UBFM) {
        *imm = 64 - bitfield_u32(insnbits, 16, constSix);
    }
    else {
        *imm = 0;
    }
    return;
}

/*
 * Logic for determining the ALU operation needed for this opcode.
 * STUDENT TO-DO:
 * Determine the ALU operation based on the given opcode
 * and write it to *ALU_op.
 */
static comb_logic_t
decide_alu_op(opcode_t op, alu_op_t *ALU_op) {
    switch (op) {
        case OP_LDUR:
        case OP_STUR:
        case OP_ADRP:
        case OP_ADD_RI:
        case OP_ADDS_RR:
        case OP_B:
        case OP_BL:
        case OP_B_COND:
            *ALU_op = PLUS_OP;
            break;
        case OP_ORR_RR:
            *ALU_op = OR_OP;
            break;
        case OP_SUB_RI:
        case OP_SUBS_RR:
        case OP_CMP_RR:
            *ALU_op = MINUS_OP;
            break;
        case OP_MOVK:
        case OP_MOVZ:
        case OP_MVN:
            *ALU_op = MOV_OP;
            break;
        case OP_EOR_RR:
            *ALU_op = EOR_OP;
            break;

        case OP_ANDS_RR:
        case OP_TST_RR:
            *ALU_op = AND_OP;
            break;
                case OP_ASR:
            *ALU_op = ASR_OP;
            break;
        case OP_LSL:
        case OP_UBFM:
            *ALU_op = LSL_OP;
            break;

        case OP_LSR:
            *ALU_op = LSR_OP;
            break;
        default:
            *ALU_op = PLUS_OP;        
    }
    return;
}

/*
 * Utility functions for copying over control signals across a stage.
 * STUDENT TO-DO:
 * Copy the input signals from the input side of the pipeline
 * register to the output side of the register.
 */

comb_logic_t 
copy_m_ctl_sigs(m_ctl_sigs_t *dest, m_ctl_sigs_t *src) {
    dest->dmem_read = src->dmem_read;
    dest->dmem_write = src->dmem_write;
    return;
}

comb_logic_t 
copy_w_ctl_sigs(w_ctl_sigs_t *dest, w_ctl_sigs_t *src) {
    dest->dst_sel = src->dst_sel;
    dest->w_enable = src->w_enable;
    dest->wval_sel = src->wval_sel;
    return;
}

comb_logic_t
extract_regs(uint32_t insnbits, opcode_t op, uint8_t *src1, uint8_t *src2, uint8_t *dst) {
    int constFive = 5;
    int constZer = 0;
    int constSixt = 16;

    switch (op) {
        case OP_LDUR:
            // Load register instruction - Set dst to bits 0-4 of instruction, src2 to 36, src1 to bits 5-9 of instruction
            *dst = bitfield_u32(insnbits, constZer, constFive);
            *src2 = 36;
            *src1 = bitfield_u32(insnbits, constFive, constFive);
            break;
        case OP_STUR:
            // Store register instruction - Set dst to bits 0-4 of instruction, src2 to 36, src1 to bits 5-9 of instruction
            *dst = bitfield_u32(insnbits, constZer, constFive);
            *src2 = 36;
            *src1 = bitfield_u32(insnbits, constFive, constFive);
            break;
        case OP_MOVK:
        case OP_MOVZ:
        case OP_ADRP:
            // Move wide immediate, Move Zero and Address of Page table instructions - Set src2 to 36, dst to bits 0-4 of instruction, src1 to bits 0-4 of instruction
            *src2 = 36;
            *dst = bitfield_u32(insnbits, constZer, constFive);
            *src1 = bitfield_u32(insnbits, constZer, constFive);
            break;
        case OP_RET:
            // Return instruction - Set dst to bits 5-9 of instruction, src1 and src2 to 36
            *dst = bitfield_u32(insnbits, constFive, constFive);
            *src1 = 36;
            *src2 = 36;
            break;
        case OP_SUBS_RR:
        case OP_ADDS_RR:
        case OP_ORR_RR:
        case OP_EOR_RR:
        case OP_ANDS_RR:
            // Register-register arithmetic and logical instructions - Set src1 to bits 5-9 of instruction, dst to bits 0-4 of instruction, src2 to bits 16-20 of instruction
            *src1 = bitfield_u32(insnbits, constFive, constFive);
            *dst = bitfield_u32(insnbits, constZer, constFive);
            *src2 = bitfield_u32(insnbits, constSixt, constFive);
            break;
        case OP_MVN:
            // Bitwise logical NOT instruction - Set dst to bits 0-4 of instruction, src2 to bits 16-20 of instruction, src1 to 36
            *dst = bitfield_u32(insnbits, constZer, constFive);
            *src2 = bitfield_u32(insnbits, constSixt, constFive);
            *src1 = 36;
            break;
        case OP_CMP_RR:
        case OP_TST_RR:
            // Compare and Test register-register instructions - Set dst to 0x20U, src2 to bits 16-20 of instruction, src1 to bits 5-9 of instruction
            *dst = 0x20U;
            *src2 = bitfield_u32(insnbits, constSixt, constFive);
            *src1 = bitfield_u32(insnbits, constFive, constFive);
            break;
        case OP_ADD_RI:
        case OP_SUB_RI:
        case OP_LSL:
        case OP_LSR:
        case OP_UBFM:
        case OP_ASR:
        // Register-immediate arithmetic and logical instructions - Set dst
            *dst = bitfield_u32(insnbits, constZer, constFive);
            *src2 = bitfield_u32(insnbits, constSixt, constFive);
            *src1 = bitfield_u32(insnbits, constFive, constFive);
            break;
    }
    return;
}

/*
 * Decode stage logic.
 * STUDENT TO-DO:
 * Implement the decode stage.
 * 
 * Use `in` as the input pipeline register,
 * and update the `out` pipeline register as output.
 * Additionally, make sure the register file is updated
 * with W_out's output when you call it in this stage.
 * 
 * You will also need the following helper functions:
 * generate_DXMW_control, regfile, extract_immval,
 * and decide_alu_op.
 */

comb_logic_t decode_instr(d_instr_impl_t *in, x_instr_impl_t *out) {

    
    // Copy input values to output
    out->status = in->status;
    out->op = in->op;
    out->print_op = in->print_op;
    out->cond = bitfield_u32(in->insnbits, 0, 4);
    out->seq_succ_PC = in->seq_succ_PC;

    // Create a pointer to a structure of control signals and set it
    d_ctl_sigs_t * deez_SIGS;
    generate_DXMW_control(in->print_op, deez_SIGS, &(out->X_sigs), &(out->M_sigs), &(out->W_sigs));

    // Decide the ALU operation based on the instruction
    decide_alu_op(in->print_op, &out->ALU_op);

    // Allocate memory for source and destination registers
    uint8_t *src1 = calloc(1,1);
    uint8_t *src2= calloc(1,1);
    uint8_t *dst= calloc(1,1);

    // Extract register values from the instruction bits
    extract_regs(in->insnbits, in->print_op, src1, src2, dst);

    // Extract immediate value from the instruction bits
    extract_immval(in->insnbits, in->print_op, &(out->val_imm));

    
    // Check if the operation is either OP_MOVK or OP_MOVZ, set out->val_hw to bits 21 to 22 if true
    if (in->print_op == OP_MOVK) {
    out->val_hw = bitfield_u32(in->insnbits, 21, 2);
    }
    else if (in->print_op == OP_MOVZ){
    out->val_hw = bitfield_u32(in->insnbits, 21, 2);
    }
    else {
    out->val_hw = 0;
    }
    // Set out->dst to the value of the variable pointed by dst
    out->dst = *dst;

    // If operation is OP_STUR, call regfile function with relevant parameters
    if (in->print_op == OP_STUR) {
        regfile(*src1, *dst, W_out->dst, W_wval, W_out->W_sigs.w_enable, &out->val_a, &out->val_b);
    }
    // If operation is OP_RET, call regfile function with relevant parameters and check if dst is not equal to 30
    else if (in->print_op == OP_RET) {
        regfile(*dst, *src1, W_out->dst, W_wval, W_out->W_sigs.w_enable, &out->val_a, &out->val_b);
        
        if (*dst != 30) {
            // Set the status of the F_in and D_in structures to STAT_INS if dst is not equal to 30
            F_in->status = STAT_INS;
            D_in->status = STAT_INS;
        }
    }
    else {
        regfile(*src1, *src2, W_out->dst, W_wval, W_out->W_sigs.w_enable, &out->val_a, &out->val_b);
    }
    return;
}